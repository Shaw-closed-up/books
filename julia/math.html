<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/static/img/favicon.png" rel="icon" type="image/png">

    <!-- Theme CSS -->
    <link href="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/css/theme.css" rel="stylesheet" type="text/css"/>
    <link href="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/css/style.css" rel="stylesheet" type="text/css"/>
    <title>Julia 数学运算和基本函数 - FreeAIHub</title>
  
    <style>
      #top_bar {
          /* background-color: #6e84a3;
          color: white;
          font: bold 12px Helvetica;
          padding: 6px 5px 4px 5px;
          border-bottom: 1px outset; */
      }
      #status {
          text-align: center;
      }
      #sendCtrlAltDelButton {
          position: fixed;
          top: 0px;
          right: 0px;
          border: 1px outset;
          padding: 5px 5px 4px 5px;
          cursor: pointer;
      }

      #screen {
          /* flex: 1;
          overflow: hidden; */
      }

  </style>

  </head>
  <body class="bg-light" style="padding-top: 84px;">
      <header class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar text-center">
      <a class="navbar-brand mr-0 mr-md-2" aria-label="引导程序" href="/">
        <img src="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/images/freeaihub.svg" width="60%" alt="freeai logo">
      </a>
      <ul class="navbar-nav ml-md-auto">
        <li class="nav-item">
          <a href="/" class="nav-link pl-2 pr-1 mx-1 py-3 my-n2">首页</a>
        </li>
        <li class="nav-item">
          <a href="/" class="nav-link pl-2 pr-1 mx-1 py-3 my-n2">课程页面</a>
        </li>
      </ul>
    </header>



    <!-- BREADCRUMB
    ================================================== -->
    <nav class="d-lg-none bg-gray-800">
      <div class="container-fluid">
        <div class="row align-items-center">
          <div class="col">
          </div>
          <div class="col-auto">
            <!-- Toggler -->
            <div class="navbar-dark">
              <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#sidenavCollapse" aria-controls="sidenavCollapse" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
              </button>
            </div>

          </div>
        </div> <!-- / .row -->
      </div> <!-- / .container -->
    </nav>

    <!-- CONTENT
    ================================================== -->
    <section style="overflow: hidden;">
      <div class="container-fluid">
        <div class="row">

          <div class="col-12 col-lg-2 col-xl-2 px-lg-0 border-bottom border-bottom-lg-0 border-right-lg border-gray-300 sidenav sidenav-left">     
            <div class="collapse d-lg-block" id="sidenavCollapse">
              <div class="px-lg-5">
                <ul class="nav side-left">
                  <li><a href="./index.html"> 如何学习本课程 </a></li>
<li><a href="./intro.html"> Julia简介 </a></li>
<li><a href="./setup.html"> Julia环境搭建及运行 </a></li>
<li><a href="./start.html"> Julia开始 </a></li>
<li><a href="./repl.html"> Julia交互 </a></li>
<li><a href="./variable.html"> Julia变量 </a></li>
<li><a href="./int-float.html"> Julia整数和浮点数 </a></li>
<li><a href="./math.html"> Julia数学运算和基本函数 </a></li>
<li><a href="./complex-fraction.html"> Julia复数和分数 </a></li>
<li><a href="./string.html"> Julia数据类型 字符串 </a></li>
<li><a href="./scope.html"> Julia变量的作用域 </a></li>
<li><a href="./function.html"> Julia函数 </a></li>
<li><a href="./method.html"> Julia方法 </a></li>
<li><a href="./conditional.html"> Julia控制流 </a></li>
<li><a href="./type.html"> Julia类型 </a></li>
<li><a href="./construction-function.html"> Julia构造函数 </a></li>
<li><a href="./type-convert.html"> Julia类型转换和类型提升 </a></li>
<li><a href="./module.html"> Julia模块 </a></li>
<li><a href="./datetime.html"> Julia日期和时间 </a></li>
<li><a href="./meta.html"> Julia元编程 </a></li>
<li><a href="./md-array.html"> Julia多维数组 </a>     </li>
<li><a href="./la.html"> Julia线性代数 </a></li>
<li><a href="./net-stream.html"> Julia网络和流 </a></li>
<li><a href="./parallel-computation.html"> Julia并行计算 </a></li>
<li><a href="./nullable.html"> Julia可空类型 </a></li>
                </ul>  

              </div>
            </div>


          </div>

          <div class="entry-cellcontent col-10 col-lg-10 col-xl-10 offset-lg-2 offset-xl-2">
          <h1>Julia 数学运算和基本函数</h1>
<h2>数学运算和基本函数</h2>
<p>Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。</p>
<h2>算术运算符</h2>
<p>下面的<a href="http://zh.wikipedia.org/zh-cn/算术#.E7.AE.97.E8.A1.93.E9.81.8B.E7.AE.97">算术运算符</a>适用于所有的基本数值类型：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>+x</code></td>
<td align="left">一元加法</td>
<td align="left">x 本身</td>
</tr>
<tr>
<td align="left"><code>-x</code></td>
<td align="left">一元减法</td>
<td align="left">相反数</td>
</tr>
<tr>
<td align="left"><code>x + y</code></td>
<td align="left">二元加法</td>
<td align="left">做加法</td>
</tr>
<tr>
<td align="left"><code>x - y</code></td>
<td align="left">二元减法</td>
<td align="left">做减法</td>
</tr>
<tr>
<td align="left"><code>x * y</code></td>
<td align="left">乘法</td>
<td align="left">做乘法</td>
</tr>
<tr>
<td align="left"><code>x / y</code></td>
<td align="left">除法</td>
<td align="left">做除法</td>
</tr>
<tr>
<td align="left"><code>x \ y</code></td>
<td align="left">反除</td>
<td align="left">等价于 y / x</td>
</tr>
<tr>
<td align="left"><code>x ^ y</code></td>
<td align="left">乘方</td>
<td align="left">x 的 y 次幂</td>
</tr>
<tr>
<td align="left"><code>x % y</code></td>
<td align="left">取余</td>
<td align="left">等价于 rem(x, y)</td>
</tr>
</tbody>
</table>
<p>以及 <code>Bool</code> 类型的非运算：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>!x</code></td>
<td align="left">非</td>
<td align="left">true 和 false 互换</td>
</tr>
</tbody>
</table>
<p>Julia 的类型提升系统使得参数类型混杂的算术运算也很简单自然。详见类型转换和类型提升 </p>
<p>算术运算的例子：</p>
<pre><code class="julia">1 + 2 + 3


1 - 2


3*2/12
</code></pre>

<p>（习惯上，优先级低的运算，前后多补些空格。这不是强制的。）</p>
<h2>位运算符</h2>
<p>下面的 位运算符 适用于所有整数类型：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>~x</code></td>
<td align="left">按位取反</td>
</tr>
<tr>
<td align="left"><code>x &amp; y</code></td>
<td align="left">按位与</td>
</tr>
<tr>
<td align="left"><code>x \| y</code></td>
<td align="left">按位或</td>
</tr>
<tr>
<td align="left"><code>x $ y</code></td>
<td align="left">按位异或</td>
</tr>
<tr>
<td align="left"><code>x &gt;&gt;&gt; y</code></td>
<td align="left">向右 逻辑移位 （高位补 0 ）</td>
</tr>
<tr>
<td align="left"><code>x &gt;&gt; y</code></td>
<td align="left">向右 算术移位 （复制原高位）</td>
</tr>
<tr>
<td align="left"><code>x &lt;&lt; y</code></td>
<td align="left">向左逻辑/算术移位</td>
</tr>
</tbody>
</table>
<p>位运算的例子：</p>
<pre><code class="julia">~123

123 &amp; 234

123 | 234

123 $ 234

~uint32(123)

~uint8(123)
</code></pre>

<h2>复合赋值运算符</h2>
<p>二元算术和位运算都有对应的复合赋值运算符，即运算的结果将会被赋值给左操作数。在操作符的后面直接加上 <code>=</code> 就组成了复合赋值运算符。例如, <code>x += 3</code> 相当于 <code>x = x + 3</code> ：</p>
<pre><code class="julia">x = 1

x += 3

x
</code></pre>

<p>复合赋值运算符有：</p>
<p><code>+=  -=  *=  /=  \=  %=  ^=  &amp;=  |=  $=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></p>
<h2>数值比较</h2>
<p>所有的基础数值类型都可以使用比较运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于等于</td>
</tr>
</tbody>
</table>
<p>一些例子：</p>
<pre><code class="julia">1 == 1

1 == 2

1 != 2

1 == 1.0

1 &lt; 2

1.0 &gt; 3

1 &gt;= 1.0

-1 &lt;= 1

-1 &lt;= -1

-1 &lt;= -2

3 &lt; -0.5
</code></pre>

<p>整数是按位比较的。浮点数是 <a href="http://zh.wikipedia.org/zh-cn/IEEE_754">IEEE 754</a> 标准 比较的：</p>
<ul>
<li>有限数按照正常方式做比较。</li>
<li>正数的零等于但不大于负数的零。</li>
<li><code>Inf</code> 等于它本身，并且大于所有数, 除了 <code>NaN</code>。</li>
<li><code>-Inf</code> 等于它本身，并且小于所有数, 除了 <code>NaN</code>。</li>
<li><code>NaN</code> 不等于、不大于、不小于任何数，包括它本身。</li>
</ul>
<p>上面最后一条是关于 <code>NaN</code> 的性质，值得留意：</p>
<pre><code class="julia">NaN == NaN

NaN != NaN

NaN &lt; NaN

NaN &gt; NaN
</code></pre>

<p><code>NaN</code> 在[<em>矩阵</em>]中使用时会带来些麻烦：</p>
<pre><code class="julia">[1 NaN] == [1 NaN]
</code></pre>

<p>Julia 提供了附加函数, 用以测试这些特殊值，它们使用哈希值来比较：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">测试</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>isequal(x, y)</code></td>
<td align="left">x 是否等价于 y</td>
</tr>
<tr>
<td align="left"><code>isfinite(x)</code></td>
<td align="left">x 是否为有限的数</td>
</tr>
<tr>
<td align="left"><code>isinf(x)</code></td>
<td align="left">x 是否为无限的数</td>
</tr>
<tr>
<td align="left"><code>isnan(x)</code></td>
<td align="left">x 是否不是数</td>
</tr>
</tbody>
</table>
<p><code>isequal</code> 函数，认为 <code>NaN</code> 等于它本身：</p>
<pre><code class="julia">isequal(NaN,NaN)

isequal([1 NaN], [1 NaN])

isequal(NaN,NaN32)
</code></pre>

<p><code>isequal</code> 也可以用来区分有符号的零：</p>
<pre><code class="julia">-0.0 == 0.0

isequal(-0.0, 0.0)
</code></pre>

<h2>链式比较</h2>
<p>与大多数语言不同，Julia 支持 <a href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">Python链式比较</a> ：</p>
<pre><code class="julia">1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
</code></pre>

<p>对标量的比较，链式比较使用 <code>&amp;&amp;</code> 运算符；对逐元素的比较使用 <code>&amp;</code> 运算符，此运算符也可用于数组。例如， <code>0 .&lt; A .&lt; 1</code> 的结果是一个对应的布尔数组，满足条件的元素返回 <code>true</code> 。</p>
<p>操作符 <code>.&lt;</code> 是特别针对数组的; 只有当 <code>A</code> 和 <code>B</code> 有着相同的大小时, <code>A .&lt; B</code> 才是合法的。比较的结果是布尔型数组, 其大小同 <code>A</code> 和 <code>B</code> 相同. 这样的操作符被称为<em>按元素</em>操作符; Julia 提供了一整套的按元素操作符: <code>.*</code>, <code>.+</code>, 等等。 有的按元素操作符也可以接受纯量, 例如上一段的 <code>0 .&lt; A .&lt; B</code>. 这种表示法的意思是, 相应的纯量操作符会被施加到每一 个元素上去。</p>
<p>注意链式比较的比较顺序：</p>
<pre><code class="julia">v(x) = (println(x); x)

v(1) &lt; v(2) &lt;= v(3)

v(1) &gt; v(2) &lt;= v(3)
</code></pre>

<p>中间的值只计算了一次，而不是像 <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code> 一样计算了两次。但是，链式比较的计算顺序是不确定的。不要在链式比较中使用带副作用（比如打印）的表达式。如果需要使用副作用表达式，推荐使用短路 <code>&amp;&amp;</code> 运算符（详见[短路求值])）。</p>
<h3>运算优先级</h3>
<p>Julia 运算优先级从高至低依次为：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">语法</td>
<td align="left"><code>.</code> 跟随 <code>::</code></td>
</tr>
<tr>
<td align="left">幂</td>
<td align="left"><code>^</code> 和 <code>.^</code> 等效</td>
</tr>
<tr>
<td align="left">分数</td>
<td align="left"><code>//</code> 和 <code>.//</code></td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left"><code>/ % &amp; \</code>和 <code>.* ./ .% .\</code></td>
</tr>
<tr>
<td align="left">位移</td>
<td align="left"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code> 和 <code>.&lt;&lt; .&gt;&gt; .&gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left"><code>+ - | $</code> 和 <code>.+ .-</code></td>
</tr>
<tr>
<td align="left">语法</td>
<td align="left"><code>: ..</code> 跟随于 <code>|&gt;</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code> 和 <code>.&gt; .&lt; .&gt;= .&lt;= .== .!=</code></td>
</tr>
<tr>
<td align="left">逻辑</td>
<td align="left"><code>&amp;&amp;</code> 跟随于 <code>||</code> 跟随于 <code>?</code></td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left"><code>= += -= *= /= //= \= ^= %= \|= &amp;= $= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code> 及 <code>.+= .-= .*= ./= .//= .\= .^= .%=</code></td>
</tr>
</tbody>
</table>
<h2>基本函数</h2>
<p>Julia 提供了一系列数学函数和运算符：</p>
<h3>舍入函数</h3>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
<th align="left">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>round(x)</code></td>
<td align="left">把 x 舍入到最近的整数</td>
<td align="left">FloatingPoint</td>
</tr>
<tr>
<td align="left"><code>iround(x)</code></td>
<td align="left">把 x 舍入到最近的整数</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left"><code>floor(x)</code></td>
<td align="left">把 x 向 -Inf 取整</td>
<td align="left">FloatingPoint</td>
</tr>
<tr>
<td align="left"><code>ifloor(x)</code></td>
<td align="left">把 x 向 -Inf 取整</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left"><code>ceil(x)</code></td>
<td align="left">把 x 向 +Inf 取整</td>
<td align="left">FloatingPoint</td>
</tr>
<tr>
<td align="left"><code>iceil(x)</code></td>
<td align="left">把 x 向 +Inf 取整</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left"><code>trunc(x)</code></td>
<td align="left">把 x 向 0 取整</td>
<td align="left">FloatingPoint</td>
</tr>
<tr>
<td align="left"><code>itrunc(x)</code></td>
<td align="left">把 x 向 0 取整</td>
<td align="left">Integer</td>
</tr>
</tbody>
</table>
<h3>除法函数</h3>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>div(x,y)</code></td>
<td align="left">截断取整除法；商向 0 舍入</td>
</tr>
<tr>
<td align="left"><code>fld(x,y)</code></td>
<td align="left">向下取整除法；商向 -Inf 舍入</td>
</tr>
<tr>
<td align="left"><code>cld(x,y)</code></td>
<td align="left">向上取整除法; 商向 +Inf 舍入</td>
</tr>
<tr>
<td align="left"><code>rem(x,y)</code></td>
<td align="left">除法余数；满足 x == div(x,y)*y + rem(x,y) ，与 x 同号</td>
</tr>
<tr>
<td align="left"><code>divrem(x,y)</code></td>
<td align="left">返回 (div(x,y),rem(x,y))</td>
</tr>
<tr>
<td align="left"><code>mod(x,y)</code></td>
<td align="left">取模余数；满足 x == fld(x,y)*y + mod(x,y) ，与 y 同号</td>
</tr>
<tr>
<td align="left"><code>mod2pi(x)</code></td>
<td align="left">对 2pi 取模余数； 0 &lt;= mod2pi(x) &lt; 2pi</td>
</tr>
<tr>
<td align="left"><code>gcd(x,y...)</code></td>
<td align="left">x, y, ... 的最大公约数，与 x 同号</td>
</tr>
<tr>
<td align="left"><code>lcm(x,y...)</code></td>
<td align="left">x, y, ... 的最小公倍数，与 x 同号</td>
</tr>
</tbody>
</table>
<h3>符号函数和绝对值函数</h3>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>abs(x)</code></td>
<td align="left">x 的幅值</td>
</tr>
<tr>
<td align="left"><code>abs2(x)</code></td>
<td align="left">x 的幅值的平方</td>
</tr>
<tr>
<td align="left"><code>sign(x)</code></td>
<td align="left">x 的正负号，返回值为 -1, 0, 或 +1</td>
</tr>
<tr>
<td align="left"><code>signbit(x)</code></td>
<td align="left">是否有符号位，有 (true) 或者 无 (false)</td>
</tr>
<tr>
<td align="left"><code>copysign(x,y)</code></td>
<td align="left">返回一个数，它具有 x 的幅值， y 的符号位</td>
</tr>
<tr>
<td align="left"><code>flipsign(x,y)</code></td>
<td align="left">返回一个数，它具有 x 的幅值， x*y 的符号位</td>
</tr>
</tbody>
</table>
<h3>乘方，对数和开方</h3>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>sqrt(x)</code></td>
<td align="left">√x x 的平方根</td>
</tr>
<tr>
<td align="left"><code>cbrt(x)</code></td>
<td align="left">?x x 的立方根</td>
</tr>
<tr>
<td align="left"><code>hypot(x,y)</code></td>
<td align="left">误差较小的 sqrt(x^2 + y^2)</td>
</tr>
<tr>
<td align="left"><code>exp(x)</code></td>
<td align="left">自然指数 e 的 x 次幂</td>
</tr>
<tr>
<td align="left"><code>expm1(x)</code></td>
<td align="left">当 x 接近 0 时，精确计算 exp(x)-1</td>
</tr>
<tr>
<td align="left"><code>ldexp(x,n)</code></td>
<td align="left">当 n 为整数时，高效计算<code>x*2^n</code></td>
</tr>
<tr>
<td align="left"><code>log(x)</code></td>
<td align="left">x 的自然对数</td>
</tr>
<tr>
<td align="left"><code>log(b,x)</code></td>
<td align="left">以 b 为底 x 的对数</td>
</tr>
<tr>
<td align="left"><code>log2(x)</code></td>
<td align="left">以 2 为底 x 的对数</td>
</tr>
<tr>
<td align="left"><code>log10(x)</code></td>
<td align="left">以 10 为底 x 的对数</td>
</tr>
<tr>
<td align="left"><code>log1p(x)</code></td>
<td align="left">当 x 接近 0 时，精确计算 log(1+x)</td>
</tr>
<tr>
<td align="left"><code>exponent(x)</code></td>
<td align="left">trunc(log2(x))</td>
</tr>
<tr>
<td align="left"><code>significand(x)</code></td>
<td align="left">returns the binary significand (a.k.a. mantissa) of a floating-point number x</td>
</tr>
</tbody>
</table>
<p>为什么要有 <code>hypot</code>, <code>expm1</code>, <code>log1p</code> 等函数，参见 John D. Cook 的博客： <a href="http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1</a>, <a href="http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">log1p</a>, <a href="http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">erfc</a> 和 <a href="http://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a> 。</p>
<h3>三角函数和双曲函数</h3>
<p>Julia 内置了所有的标准三角函数和双曲函数</p>
<p><code>sin    cos    tan    cot    sec    csc sinh   cosh   tanh   coth   sech   csch asin   acos   atan   acot   asec   acsc asinh  acosh  atanh  acoth  asech  acsch sinc   cosc   atan2</code></p>
<p>除了 <a href="http://zh.wikipedia.org/zh-cn/Atan2">atan2</a> 之外，都是单参数函数。 <code>atan2</code> 给出了 <code>x</code> 轴，与由 <code>x</code> 、 <code>y</code> 确定的点之间的<a href="http://zh.wikipedia.org/zh-cn/弧度">弧度</a> 。</p>
<p>另外，<code>sinpi(x)</code>和 <code>cospi(x)</code>各自被提供给更准确的 <code>sin(pi*x)</code>和 <code>cos(pi*x)</code>的计算。</p>
<p>如果想要以度，而非弧度，为单位计算三角函数，应使用带 d 后缀的函数。例如，sind(x) 计算 x 的正弦值，这里 x 的单位是度。以下的列表是全部的以度为单位的三角函数：</p>
<p><code>sind   cosd   tand   cotd   secd   cscd asind  acosd  atand  acotd  asecd  acscd</code></p>
<h3>特殊函数</h3>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>erf(x)</code></td>
<td align="left">x 处的 误差函数</td>
</tr>
<tr>
<td align="left"><code>erfc(x)</code></td>
<td align="left">补误差函数。当 x 较大时，精确计算 1-erf(x)</td>
</tr>
<tr>
<td align="left"><code>erfinv(x)</code></td>
<td align="left">erf 的反函数</td>
</tr>
<tr>
<td align="left"><code>erfcinv(x)</code></td>
<td align="left">erfc 的反函数</td>
</tr>
<tr>
<td align="left"><code>erfi(x)</code></td>
<td align="left">将误差函数定义为 -im <em>erf(x</em> im) ，其中 im 是虚数单位</td>
</tr>
<tr>
<td align="left"><code>erfcx(x)</code></td>
<td align="left">缩放的互补误差函数，即对较大的 x 值的准确的 exp（x ^ 2）* erfc（x）</td>
</tr>
<tr>
<td align="left"><code>dawson(x)</code></td>
<td align="left">缩放虚误差函数，又名道森函数，即对较大的 x 值求精确的 exp(-x^2) <em>erfi(x)</em> sqrt(pi) / 2</td>
</tr>
<tr>
<td align="left"><code>gamma(x)</code></td>
<td align="left">x 处的 gamma 函数</td>
</tr>
<tr>
<td align="left"><code>lgamma(x)</code></td>
<td align="left">当 x 较大时，精确计算 log(gamma(x))</td>
</tr>
<tr>
<td align="left"><code>lfact(x)</code></td>
<td align="left">对较大的 x 求精确的 log(factorial(x)); 与对大于 1 的 x 值求 lgamma(x+1) 相等, 否则等于 0</td>
</tr>
<tr>
<td align="left"><code>digamma(x)</code></td>
<td align="left">x 处的 digamma 函数，即导数的衍生</td>
</tr>
<tr>
<td align="left"><code>beta(x,y)</code></td>
<td align="left">在（x,y）处的 beta 函数</td>
</tr>
<tr>
<td align="left"><code>lbeta(x,y)</code></td>
<td align="left">对较大的 x 或 y 值求准确的 log(beta(x,y))</td>
</tr>
<tr>
<td align="left"><code>eta(x)</code></td>
<td align="left">x 处的 Dirichlet eta 函数</td>
</tr>
<tr>
<td align="left"><code>zeta(x)</code></td>
<td align="left">x 处的 Riemann zeta 函数</td>
</tr>
<tr>
<td align="left"><code>airy(z)</code>, <code>airyai(z)</code>, <code>airy(0,z)</code></td>
<td align="left">z 处的 Airy Ai 函数</td>
</tr>
<tr>
<td align="left"><code>airyprime(z)</code>, <code>airyaiprime(z)</code>, <code>airy(1,z)</code></td>
<td align="left">Airy Ai 函数在 z 处的导数</td>
</tr>
<tr>
<td align="left"><code>airybi(z)</code>, <code>airy(2,z)</code></td>
<td align="left">z 处的 Airy Bi 函数</td>
</tr>
<tr>
<td align="left"><code>airybiprime(z)</code>, <code>airy(3,z)</code></td>
<td align="left">Airy Bi 函数在 z 处的导数</td>
</tr>
<tr>
<td align="left"><code>airyx(z)</code>, <code>airyx(k,z)</code></td>
<td align="left">缩放 Airy Ai 函数 以及 k 对 z 的导数</td>
</tr>
<tr>
<td align="left"><code>besselj(nu,z)</code></td>
<td align="left">对 z 中一阶 nu 的贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>besselj0(z)</code></td>
<td align="left">besselj(0,z)</td>
</tr>
<tr>
<td align="left"><code>besselj1(z)</code></td>
<td align="left">besselj(1,z)</td>
</tr>
<tr>
<td align="left"><code>besseljx(nu,z)</code></td>
<td align="left">对 z 中一阶 nu 的缩放贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>bessely(nu,z)</code></td>
<td align="left">对 z 中二阶 nu 的贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>bessely0(z)</code></td>
<td align="left">bessely(0,z)</td>
</tr>
<tr>
<td align="left"><code>bessely1(z)</code></td>
<td align="left">bessely(1,z)</td>
</tr>
<tr>
<td align="left"><code>besselyx(nu,z)</code></td>
<td align="left">对 z 中二阶 nu 的缩放贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>besselh(nu,k,z)</code></td>
<td align="left">对 z 中三阶 nu （例如汉克尔函数）的贝塞尔函数； k 必须为 1 或 2</td>
</tr>
<tr>
<td align="left"><code>hankelh1(nu,z)</code></td>
<td align="left">besselh(nu, 1, z)</td>
</tr>
<tr>
<td align="left"><code>hankelh1x(nu,z)</code></td>
<td align="left">缩放 besselh(nu, 1, z)</td>
</tr>
<tr>
<td align="left"><code>hankelh2(nu,z)</code></td>
<td align="left">besselh(nu, 2, z)</td>
</tr>
<tr>
<td align="left"><code>hankelh2x(nu,z)</code></td>
<td align="left">缩放 besselh(nu, 2, z)</td>
</tr>
<tr>
<td align="left"><code>besseli(nu,z)</code></td>
<td align="left">对 z 中一阶 nu 的修正贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>besselix(nu,z)</code></td>
<td align="left">对 z 中一阶 nu 的缩放修正贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>besselk(nu,z)</code></td>
<td align="left">对 z 中二阶 nu 的修正贝塞尔函数</td>
</tr>
<tr>
<td align="left"><code>besselkx(nu,z)</code></td>
<td align="left">对二阶 o 的缩放修正贝塞尔函数</td>
</tr>
</tbody>
</table>
          </div>
          <backend type='k'></backend>
          <code class=gatsby-kernelname data-language=julia></code>
        </div> <!-- / .row -->
      </div>
      
    </section>

    <!-- JAVASCRIPT
    ================================================== -->
    <!-- Libs JS -->
    <script src="https://landkit.goodthemes.co/assets/libs/jquery/dist/jquery.min.js"></script>
    <script src="https://landkit.goodthemes.co/assets/libs/bootstrap/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Theme JS -->
    <script src="https://landkit.goodthemes.co/assets/js/theme.min.js"></script>
    <script src="https://cdn.freeaihub.com/asset/js/cell.js"></script>
          
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
    MathJax = {
      tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  </body>
</html>