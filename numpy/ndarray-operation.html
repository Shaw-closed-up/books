<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="/static/img/favicon.png" rel="icon" type="image/png">

    <!-- Theme CSS -->
    <link href="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/css/theme.css" rel="stylesheet" type="text/css"/>
    <link href="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/css/style.css" rel="stylesheet" type="text/css"/>
    <title>Numpy 数组操作 - FreeAIHub</title>
  
    <style>
      #top_bar {
          /* background-color: #6e84a3;
          color: white;
          font: bold 12px Helvetica;
          padding: 6px 5px 4px 5px;
          border-bottom: 1px outset; */
      }
      #status {
          text-align: center;
      }
      #sendCtrlAltDelButton {
          position: fixed;
          top: 0px;
          right: 0px;
          border: 1px outset;
          padding: 5px 5px 4px 5px;
          cursor: pointer;
      }

      #screen {
          /* flex: 1;
          overflow: hidden; */
      }

  </style>

  </head>
  <body class="bg-light" style="padding-top: 84px;">
      <!-- NAVBAR
    ================================================== -->
    <nav class="navbar navbar-expand-lg navbar-light fixed-top bg-white border-bottom">
      <div class="container-fluid" style="height: 42px;">

        <!-- Brand -->
        <a class="navbar-brand" href="../index.html">

          <img src="https://freeaihub.oss-cn-beijing.aliyuncs.com/asset/images/freeaihub.svg" width="60%" alt="freeai logo">
        </a>

        <!-- Toggler -->
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <!-- Collapse -->
        <div class="collapse navbar-collapse" id="navbarCollapse">

          <!-- Toggler -->
          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
            <i class="fe fe-x"></i>
          </button>

          <!-- Navigation -->
          <ul class="navbar-nav ml-auto">
         
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#banner">首页</a>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#banner">课程页面</a>
            </li>
            <li class="nav-item dropdown">
            
            </li>
          </ul>
        </div>

      </div>
    </nav>


    <!-- BREADCRUMB
    ================================================== -->
    <nav class="d-lg-none bg-gray-800">
      <div class="container-fluid">
        <div class="row align-items-center">
          <div class="col">
          </div>
          <div class="col-auto">
            <!-- Toggler -->
            <div class="navbar-dark">
              <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#sidenavCollapse" aria-controls="sidenavCollapse" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
              </button>
            </div>

          </div>
        </div> <!-- / .row -->
      </div> <!-- / .container -->
    </nav>

    <!-- CONTENT
    ================================================== -->
    <section style="overflow: hidden;">
      <div class="container-fluid">
        <div class="row">

          <div class="col-12 col-lg-2 col-xl-2 px-lg-0 border-bottom border-bottom-lg-0 border-right-lg border-gray-300 sidenav sidenav-left">     
            <div class="collapse d-lg-block" id="sidenavCollapse">
              <div class="px-lg-5">
                <ul class="nav side-left">
                  <li><a href="./index.html"> 如何学习本课程</a></li>
<li><a href="./intro.html"> NumPy简介</a></li>
<li><a href="./setup.html"> NumPy安装</a></li>
<li><a href="./datatype.html"> NumPy数据类型</a></li>
<li><a href="./ndarray.html"> NumPyNDArray</a></li>
<li><a href="./ndarray-creation.html"> NumPy创建NDArray</a></li>
<li><a href="./ndarray-property.html"> NumPyNDArray属性</a></li>
<li><a href="./ndarray-operation.html"> NumPy操作NDArray</a></li>
<li><a href="./slice-index.html"> NumPy切片和索引</a></li>
<li><a href="./advance-index.html"> NumPy高级索引</a></li>
<li><a href="./broadcast.html"> NumPy广播</a></li>
<li><a href="./bit-operation.html"> NumPy位运算</a></li>
<li><a href="./math.html"> NumPy数学函数</a></li>
<li><a href="./arithmetic.html"> NumPy算术函数</a></li>
<li><a href="./statistics.html"> NumPy统计函数</a></li>
<li><a href="./sort.html"> NumPy排序</a></li>
<li><a href="./statistics.html"> NumPy统计函数</a></li>
<li><a href="./linalg.html"> NumPy线性代数</a></li>
<li><a href="./matrix.html"> NumPy矩阵</a></li>
                </ul>  

              </div>
            </div>


          </div>

          <div class="entry-cellcontent col-10 col-lg-10 col-xl-10 offset-lg-2 offset-xl-2">
          <h1>Numpy 数组操作</h1>
<p>Numpy 中包含了一些函数用于处理数组，大概可分为以下几类：</p>
<h2>修改数组形状</h2>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>reshape</code></td>
<td align="left">不改变数据的条件下修改形状</td>
</tr>
<tr>
<td align="left"><code>flat</code></td>
<td align="left">数组元素迭代器</td>
</tr>
<tr>
<td align="left"><code>flatten</code></td>
<td align="left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td>
</tr>
<tr>
<td align="left"><code>ravel</code></td>
<td align="left">返回展开数组</td>
</tr>
</tbody>
</table>
<h3>numpy.reshape</h3>
<p>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order='C')</p>
<ul>
<li><code>arr</code>：要修改形状的数组</li>
<li><code>newshape</code>：整数或者整数数组，新的形状应当兼容原有形状</li>
<li>order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'k' -- 元素在内存中的出现顺序。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(8) 
print('原始数组：') 
print(a) 
print('\n')  
b = a.reshape(4,2) 
print('修改后的数组：') 
print(b)
</code></pre>

<h3>numpy.ndarray.flat</h3>
<p>numpy.ndarray.flat 是一个数组元素迭代器</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(9).reshape(3,3)  
print('原始数组：') 
for row in a:
    print(row)  #对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器： 
    print('迭代后的数组：') 
    for element in a.flat:
        print(element)
</code></pre>

<h3>numpy.ndarray.flatten</h3>
<p>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p>
<pre><code>ndarray.flatten(order='C')
</code></pre>

<p>参数说明：</p>
<ul>
<li>order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'K' -- 元素在内存中的出现顺序。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(8).reshape(2,4)  
print('原数组：') 
print(a) 
print('\n') 

# 默认按行  print('展开的数组：') 
print(a.flatten()) 
print('\n') 

print('以 F 风格顺序展开的数组：')
print(a.flatten(order = 'F'))
</code></pre>

<h3>numpy.ravel</h3>
<p>numpy.ravel() 展平的数组元素，顺序通常是"C风格"，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p>
<p>该函数接收两个参数：</p>
<pre><code>numpy.ravel(a, order='C')
</code></pre>

<p>参数说明：</p>
<ul>
<li>order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'K' -- 元素在内存中的出现顺序。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(8).reshape(2,4)  
print('原数组：') 
print(a) 
print('\n')  

print('调用 ravel 函数之后：') 
print(a.ravel())
print('\n')

print('以 F 风格顺序调用 ravel 函数之后：')
print(a.ravel(order = 'F'))
</code></pre>

<h2>翻转数组</h2>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>transpose</code></td>
<td align="left">对换数组的维度</td>
</tr>
<tr>
<td align="left"><code>ndarray.T</code></td>
<td align="left">和 <code>self.transpose()</code> 相同</td>
</tr>
<tr>
<td align="left"><code>rollaxis</code></td>
<td align="left">向后滚动指定的轴</td>
</tr>
<tr>
<td align="left"><code>swapaxes</code></td>
<td align="left">对换数组的两个轴</td>
</tr>
</tbody>
</table>
<h3>numpy.transpose</h3>
<p>numpy.transpose 函数用于对换数组的维度，格式如下：</p>
<pre><code>numpy.transpose(arr, axes)
</code></pre>

<p>参数说明:</p>
<ul>
<li><code>arr</code>：要操作的数组</li>
<li><code>axes</code>：整数列表，对应维度，通常所有维度都会对换。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(12).reshape(3,4)
print('原数组：') 
print(a) 
print('\n')  

print('对换数组：') 
print(np.transpose(a))
</code></pre>

<p>numpy.ndarray.T 类似 numpy.transpose：</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(12).reshape(3,4)  

print('原数组：') 
print(a) 
print('\n')  

print('转置数组：')
print(a.T)
</code></pre>

<h3>numpy.rollaxis</h3>
<p>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</p>
<pre><code>numpy.rollaxis(arr, axis, start)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：数组</li>
<li><code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变</li>
<li><code>start</code>：默认为零，表示完整的滚动。会滚动到特定位置。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
# 创建了三维的 ndarray 
a = np.arange(8).reshape(2,2,2)  
print('原数组：') 
print(a) 
print('\n') 

# 将轴 2 滚动到轴 0（宽度到深度）  
print('调用 rollaxis 函数：') 
print(np.rollaxis(a,2)) 

# 将轴 0 滚动到轴 1：（宽度到高度）
print('\n')
print('调用 rollaxis 函数：') 
print(np.rollaxis(a,2,1))
</code></pre>

<h3>numpy.swapaxes</h3>
<p>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</p>
<pre><code>numpy.swapaxes(arr, axis1, axis2)
</code></pre>

<ul>
<li><code>arr</code>：输入的数组</li>
<li><code>axis1</code>：对应第一个轴的整数</li>
<li><code>axis2</code>：对应第二个轴的整数</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
# 创建了三维的 ndarray 
a = np.arange(8).reshape(2,2,2)  
print('原数组：') 
print(a) 
print('\n') 


# 现在交换轴 0（深度方向）到轴 2（宽度方向）  
print('调用 swapaxes 函数后的数组：') 
print(np.swapaxes(a, 2, 0))
</code></pre>

<h2>修改数组维度</h2>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>broadcast</code></td>
<td align="left">产生模仿广播的对象</td>
</tr>
<tr>
<td align="left"><code>broadcast_to</code></td>
<td align="left">将数组广播到新形状</td>
</tr>
<tr>
<td align="left"><code>expand_dims</code></td>
<td align="left">扩展数组的形状</td>
</tr>
<tr>
<td align="left"><code>squeeze</code></td>
<td align="left">从数组的形状中删除一维条目</td>
</tr>
</tbody>
</table>
<h3>numpy.broadcast</h3>
<p>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p>
<p>该函数使用两个数组作为输入参数，如下实例：</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
x = np.array([[1], [2], [3]]) 
y = np.array([4, 5, 6])    

# 对 y 广播 x 
b = np.broadcast(x,y)  


# 它拥有 iterator 属性，基于自身组件的迭代器元组  
print('对 y 广播 x：') 
r,c = b.iters  


# Python3.x 为 next(context) ，Python2.x 为 context.next() 
print(next(r), next(c)) 
print(next(r), next(c))
print('\n') 

# shape 属性返回广播对象的形状  
print('广播对象的形状：') 
print(b.shape)
print('\n') 

# 手动使用 broadcast 将 x 与 y 相加 
b = np.broadcast(x,y) 
c = np.empty(b.shape)
print('手动使用 broadcast 将 x 与 y 相加：') 
print(c.shape) 
print('\n') 

c.flat = [u + v for (u,v) in b]  
print('调用 flat 函数：') 
print(c) 
print('\n') 

# 获得了和 NumPy 内建的广播支持相同的结果
print('x 与 y 的和：')
print(x + y)
</code></pre>

<h3>numpy.broadcast_to</h3>
<p>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p>
<pre><code>numpy.broadcast_to(array, shape, subok)
</code></pre>

<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(4).reshape(1,4)  
print('原数组：') 
print(a) 
print('\n')  

print('调用 broadcast_to 函数之后：') 
print(np.broadcast_to(a,(4,4)))
</code></pre>

<h3>numpy.expand_dims</h3>
<p>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</p>
<pre><code> numpy.expand_dims(arr, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>axis</code>：新轴插入的位置</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
x = np.array(([1,2],[3,4]))  
print('数组 x：') 
print(x) 
print('\n') 


y = np.expand_dims(x, axis = 0)  
print('数组 y：') 
print(y) 
print('\n')  

print('数组 x 和 y 的形状：')
print(x.shape, y.shape) 
print('\n') 


# 在位置 1 插入轴 
y = np.expand_dims(x, axis = 1)  
print('在位置 1 插入轴之后的数组 y：') 
print(y) 
print('\n')  


print('x.ndim 和 y.ndim：') 
print(x.ndim,y.ndim) 
print('\n')
print('x.shape 和 y.shape：') 
print(x.shape, y.shape)
</code></pre>

<h3>numpy.squeeze</h3>
<p>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</p>
<pre><code>numpy.squeeze(arr, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>axis</code>：整数或整数元组，用于选择形状中一维条目的子集</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
x = np.arange(9).reshape(1,3,3)

print('数组 x：')
print(x) 
print('\n') 
y = np.squeeze(x)  

print('数组 y：') 
print(y)
print('\n')

print('数组 x 和 y 的形状：') 
print(x.shape, y.shape)

</code></pre>

<h2>连接数组</h2>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>concatenate</code></td>
<td align="left">连接沿现有轴的数组序列</td>
</tr>
<tr>
<td align="left"><code>stack</code></td>
<td align="left">沿着新的轴加入一系列数组。</td>
</tr>
<tr>
<td align="left"><code>hstack</code></td>
<td align="left">水平堆叠序列中的数组（列方向）</td>
</tr>
<tr>
<td align="left"><code>vstack</code></td>
<td align="left">竖直堆叠序列中的数组（行方向）</td>
</tr>
</tbody>
</table>
<h3>numpy.concatenate</h3>
<p>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</p>
<pre><code>numpy.concatenate((a1, a2, ...), axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>a1, a2, ...</code>：相同类型的数组</li>
<li><code>axis</code>：沿着它连接数组的轴，默认为 0</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([[1,2],[3,4]])  
print('第一个数组：') 
print(a) 
print('\n') 

b = np.array([[5,6],[7,8]])  
print('第二个数组：') 
print(b) 
print('\n') 


# 两个数组的维度相同
print('沿轴 0 连接两个数组：')
print(np.concatenate((a,b)))
print('\n')

print('沿轴 1 连接两个数组：') 
print(np.concatenate((a,b),axis = 1))
</code></pre>

<h3>numpy.stack</h3>
<p>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</p>
<pre><code>numpy.stack(arrays, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arrays</code>相同形状的数组序列</li>
<li><code>axis</code>：返回数组中的轴，输入数组沿着它来堆叠</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np
a = np.array([[1,2],[3,4]])

print('第一个数组：')
print(a) 
print('\n') 

print('第二个数组：')
b = np.array([[5,6],[7,8]]) 
print(b) 
print('\n')  

print('沿轴 0 堆叠两个数组：') 
print(np.stack((a,b),0)) 
print('\n')  

print('沿轴 1 堆叠两个数组：') 
print(np.stack((a,b),1))
</code></pre>

<h3>numpy.hstack</h3>
<p>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([[1,2],[3,4]])  
print('第一个数组：') 
print(a) 
print('\n') 
b = np.array([[5,6],[7,8]])  
print('第二个数组：') 
print(b) 
print('\n')  

print('水平堆叠：')
c = np.hstack((a,b)) 
print(c)
print('\n')
</code></pre>

<h3>numpy.vstack</h3>
<p>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np
a = np.array([[1,2],[3,4]])  

print('第一个数组：') 
print(a) 
print('\n') 

b = np.array([[5,6],[7,8]])  
print('第二个数组：') 
print(b)
print('\n') 

print('竖直堆叠：') 
c = np.vstack((a,b))
print(c)
</code></pre>

<h2>分割数组</h2>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">数组及操作</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>split</code></td>
<td align="left">将一个数组分割为多个子数组</td>
</tr>
<tr>
<td align="left"><code>hsplit</code></td>
<td align="left">将一个数组水平分割为多个子数组（按列）</td>
</tr>
<tr>
<td align="left"><code>vsplit</code></td>
<td align="left">将一个数组垂直分割为多个子数组（按行）</td>
</tr>
</tbody>
</table>
<h3>numpy.split</h3>
<p>numpy.split 函数沿特定的轴将数组分割为子数组，格式如下：</p>
<pre><code>numpy.split(ary, indices_or_sections, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>ary</code>：被分割的数组</li>
<li><code>indices_or_sections</code>：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li>
<li><code>axis</code>：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(9)  
print('第一个数组：') 
print(a) 
print('\n')  


print('将数组分为三个大小相等的子数组：') 
b = np.split(a,3)
print(b) 
print('\n')  


print('将数组在一维数组中表明的位置分割：') 
b = np.split(a,[4,7]) 
print(b)
</code></pre>

<h3>numpy.hsplit</h3>
<p>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
harr = np.floor(10 * np.random.random((2, 6))) 

print('原array：') 
print(harr)  

print('拆分后：') 
print(np.hsplit(harr, 3))
</code></pre>

<h3>numpy.vsplit</h3>
<p>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</p>
<h4>练习</h4>
<pre><code class="python">import numpy as np
a = np.arange(16).reshape(4,4)  

print('第一个数组：') 
print(a) 
print('\n')  

print('竖直分割：') 
b = np.vsplit(a,2) 
print(b)
</code></pre>

<h2>数组元素的添加与删除</h2>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">元素及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>resize</code></td>
<td align="left">返回指定形状的新数组</td>
</tr>
<tr>
<td align="left"><code>append</code></td>
<td align="left">将值添加到数组末尾</td>
</tr>
<tr>
<td align="left"><code>insert</code></td>
<td align="left">沿指定轴将值插入到指定下标之前</td>
</tr>
<tr>
<td align="left"><code>delete</code></td>
<td align="left">删掉某个轴的子数组，并返回删除后的新数组</td>
</tr>
<tr>
<td align="left"><code>unique</code></td>
<td align="left">查找数组内的唯一元素</td>
</tr>
</tbody>
</table>
<h3>numpy.resize</h3>
<p>numpy.resize 函数返回指定大小的新数组。</p>
<p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p>
<pre><code>numpy.resize(arr, shape)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：要修改大小的数组</li>
<li><code>shape</code>：返回数组的新形状</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([[1,2,3],[4,5,6]])
print('第一个数组：') 
print(a) 
print('\n')

print('第一个数组的形状：') 
print(a.shape)
print('\n') 
b = np.resize(a, (3,2))  

print('第二个数组：') 
print(b) 
print('\n')  

print('第二个数组的形状：') 
print(b.shape) 
print('\n') 


# 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了  
print('修改第二个数组的大小：') 
b = np.resize(a,(3,3)) 
print(b)
</code></pre>

<h3>numpy.append</h3>
<p>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p>
<p>append 函数返回的始终是一个一维数组。</p>
<pre><code>numpy.append(arr, values, axis=None)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）</li>
<li><code>axis</code>：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([[1,2,3],[4,5,6]])  
print('第一个数组：') 
print(a) 
print('\n') 

print('向数组添加元素：') 
print(np.append(a, [7,8,9])) 
print('\n')  

print('沿轴 0 添加元素：') 
print(np.append(a, [[7,8,9]],axis = 0)) 
print('\n')  

print('沿轴 1 添加元素：') 
print(np.append(a, [[5,5,5],[7,8,9]],axis = 1))
</code></pre>

<h3>numpy.insert</h3>
<p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p>
<p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p>
<pre><code>numpy.insert(arr, obj, values, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：在其之前插入值的索引</li>
<li><code>values</code>：要插入的值</li>
<li><code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([[1,2],[3,4],[5,6]])  

print('第一个数组：') 
print(a) 
print('\n')  

print('未传递 Axis 参数。 在插入之前输入数组会被展开。') 
print(np.insert(a,3,[11,12]))
print('\n') 

print('传递了 Axis 参数。 会广播值数组来配输入数组。')  
print('沿轴 0 广播：') 
print(np.insert(a,1,[11],axis = 0)) 
print('\n')  

print('沿轴 1 广播：') 
print(np.insert(a,1,11,axis = 1))
</code></pre>

<h3>numpy.delete</h3>
<p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p>
<pre><code>Numpy.delete(arr, obj, axis)
</code></pre>

<p>参数说明：</p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li>
<li><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.arange(12).reshape(3,4)  
print('第一个数组：') 
print(a) 
print('\n')  

print('未传递 Axis 参数。 在插入之前输入数组会被展开。') 
print(np.delete(a,5)) 
print('\n')  

print('删除第二列：') 
print(np.delete(a,1,axis = 1)) 
print('\n')  

print('包含从数组中删除的替代值的切片：') 
a = np.array([1,2,3,4,5,6,7,8,9,10]) 
print(np.delete(a, np.s_[::2]))
</code></pre>

<h3>numpy.unique</h3>
<p>numpy.unique 函数用于去除数组中的重复元素。</p>
<pre><code>numpy.unique(arr, return_index, return_inverse, return_counts)
</code></pre>

<ul>
<li><code>arr</code>：输入数组，如果不是一维数组则会展开</li>
<li><code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li>
<li><code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li>
<li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数</li>
</ul>
<h4>练习</h4>
<pre><code class="python">import numpy as np  
a = np.array([5,2,6,2,7,5,6,8,2,9])  
print('第一个数组：') 
print(a) 
print('\n')  

print('第一个数组的去重值：') 
u = np.unique(a) 
print(u) 
print('\n')  

print('去重数组的索引数组：') 
u,indices = np.unique(a, return_index = True) 
print(indices)
print('\n')  

print('我们可以看到每个和原数组下标对应的数值：') 
print(a) 
print('\n')  

print('去重数组的下标：') 
u,indices = np.unique(a,return_inverse = True) 
print(u) 
print('\n')  

print('下标为：') 
print(indices) 
print('\n')  

print('使用下标重构原数组：') 
print(u[indices]) 
print('\n')  

print('返回去重元素的重复数量：') 
u,indices = np.unique(a,return_counts = True) 
print(u) 
print(indices)
</code></pre>
          </div>
          <backend type="k"></backend>
          <code class=gatsby-kernelname data-language=python></code>
        </div> <!-- / .row -->
      </div>
      
    </section>

    <!-- JAVASCRIPT
    ================================================== -->
    <!-- Libs JS -->
    <script src="https://landkit.goodthemes.co/assets/libs/jquery/dist/jquery.min.js"></script>
    <script src="https://landkit.goodthemes.co/assets/libs/bootstrap/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Theme JS -->
    <script src="https://landkit.goodthemes.co/assets/js/theme.min.js"></script>
    <script src="https://cdn.freeaihub.com/asset/js/cell.js"></script>
          
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
    MathJax = {
      tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  </body>
</html>